编程语言知识与应用（15%）、通用规范理解与应用（25%）、安全规范理解与应用（25%） 、 安全可信基础知识（5%）、可信编程能力（30%）5个部分；
----------------------------------------
数组A是一个有序的整型数组，且数组中的每个数字都是唯一的，但是数组中有缺失的数字，找出从数组最左边开始的第k个缺失数字。
示例 1：
输入：A = [1,2,3,4], k=1
输出：5
解释：
全部有序，第一个缺失数字为5 。
示例 2：
输入：A = [4,7,9,10], k= 3
输出：8
解释： 
缺失数字有 [5,6,8,...]，因此第三个缺失数字为8 。
示例3：
输入：A = [1,2,4], k= 3
输出：6
解释：
缺失数字有 [3,5,6,7,...]，因此第三个缺失数字为 6 。
 
提示：
1<= A.length<=50000
1<= A[i] <=1e7
1<=K<=1e8
--------------------------------------------------------
假设有一个整数数组arrays和一个正整数num，设计一个算法判断是否有可能把这个数组分成num个非空子集，其总和都相等。如果能找到，返回true，否则返回false
示例 1：
输入：arrays = [4, 3, 2, 3, 5, 2, 1], num = 4
输出：true
说明：有可能将其分成4个子集（5），（1,4），（2,3），（2,3），这几个数组总和相等。
 
提示：
1 <= num<= len(arrays) <= 16
0 < arrays[i] < 10000
import java.util.*;
class Solution {
    public boolean canPartitionKSubsets(int[] arrays, int num) {
       // 添加实现代码，前面可添加新方法、包含文件等修改

    }
}
--------------------------------------------------------

使用“HH:MM”格式表示某一时刻，比如“12:08”，利用当前出现过的数字（这里为1、2、0、8）构造下一个距离当前时间最近的时刻。其中每个出现数字都可以被无限次使用，这里会返回“12:10”。给定的字符串一定是合法的，只能包含数字和“:”。例如，“01:11” 和 “09:09” 是合法的，而“1:4”和“11:9”是不合法的。

样例 1:
输入: "12:08"
输出: "12:10"
解释: 利用数字1、2、0、8构造出来的最近时刻是 12:10，是2 分钟之后。
 
样例 2:
输入: "23:59"
输出: "22:22"
解释: 利用数字 2, 3, 5, 9 构造出来的最近时刻是 22:22。 答案一定是第二天的某一时刻，所以选择可构造的最小时刻。
import java.util.*;
class Solution {
    public String nextClosestTime(String time) {
        // 添加实现代码，前面可添加新方法、包含文件等修改

    }
}
https://blog.csdn.net/qq_21201267/article/details/107393074
有一包含有向图的边的数组edges，以及该图的始点src和目标终点dest，设计一个算法判断从始点src出发的所有路径是否最终结束于目标终点dest，即：
从始点src到目标终点dest存在至少一条路径
如果存在从始点src到没有出边的节点的路径，则该节点就是路径终点。
从始点src到目标终点dest的可能路径数是有限数字
当从始点src出发的所有路径都可以到达目标终点dest时返回true，否则返回false。

示例 1：
输入：n = 3, edges = [[0,1],[0,2]], src = 0, dest= 2
输出：false
说明：节点1和节点2都可以到达，但也会卡在那里。
示例 2：
输入：n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], src = 0, dest= 3
输出：false
说明：有两种可能：在节点3处结束，或是在节点1和节点2之间无限循环。
示例 3：
输入：n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], src = 0, dest= 3
输出：true
示例 4：
输入：n = 3, edges = [[0,1],[1,1],[1,2]], src = 0, dest= 2
输出：false
说明：从始点出发的所有路径都在目标终点结束，但存在无限多的路径，如0-1-2，0-1-1-2，0-1-1-1-2，0-1-1-1-1-2等。

提示：
给定的图中可能带有自环和平行边。
1<= n <= 10000
0 <= edges.length <= 10000
edges[i].length = 2
0 <= src <= n - 1
0 <= desti<= n – 1
import java.util.*;
class Solution {
    public boolean leadsToDestination(int n, int[][] edges, int src, int dest)  {
       // 添加实现代码，前面可添加新方法、包含文件等修改
    }
}

假设有一棵二叉树，有n个结点，设计一个算法判断是否可以通过去掉树上的一条边将树分成两棵，且这两棵树结点之和相等。如果能找到返回true，如果不能则返回false。

样例1:
输入: [5,10,10,null,null,2,3]     
    5
   / \
  10 10
    /  \
   2   3
输出: True
解释: 可拆分如下两课树，结点和均为15
    5
   / 
  10      
 和：
   10
  /  \
 2    3
 
样例2:
输入:  [1,2,10,null,null,2,20]   
    1
   / \
  2  10
    /  \
   2   20
输出: False
解释: 无法通过移除一条树边将这棵树划分成结点之和相等的两棵子树。
注意：
树上结点的权值范围[-100000, 100000]。
1 <= n <= 10000
/**
 * Definition for a binary tree node. public class TreeNode { int val; TreeNode
 * left; TreeNode right; TreeNode(int x) { val = x; } }
 */
import java.util.*;

class Solution {
    public boolean checkEqualTree(TreeNode root) {
        // 添加实现代码，前面可添加新方法、包含文件等修改

    }
}
